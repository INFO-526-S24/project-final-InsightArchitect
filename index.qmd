---
title: "Global Poverty Trends: A Comprehensive Dataset for Research and Development"
subtitle: "INFO 526 - Project Final"
author: 
  - name: "InsightArchitect - Ayesha, Shreemithra, Anusha, Eeshaan, Kaarthik, Amaan"
    affiliations:
      - name: "School of Information, University of Arizona"
description: "Project description"
format:
   html:
    code-tools: true
    code-overflow: wrap
    embed-resources: true
editor: visual
execute:
  warning: false
  echo: false
---

## Abstract

This project by Insight Architect harnesses a comprehensive data-set on global poverty trends from Our World in Data to provide actionable insights into the dynamics of poverty across different regions and timelines. Utilizing advanced data visualization tools the shiny app in R, the project aims to enhance the understanding of poverty patterns and the effectiveness of various interventions.he dataset, encompassing 4,877 rows and 108 columns, is rich in metrics such as the headcount ratio at the international poverty line, Gini coefficients, and other inequality indices, which are crucial for analyzing poverty trends and wealth distribution among different income groups.

the project will address pivotal questions regarding the reduction of extreme poverty, the distribution of wealth, and the impact of welfare regimes and economic growth on income inequality. By focusing on these areas, the research intends to uncover the nuances of poverty alleviation efforts and economic policies across various global regions over the past three decades.
------------------------------------------------------------------------

## Introduction

```{r}
#| label: load-pkgs
#| message: false
#| echo: false
#| warning: false

library(tidyverse,
        png)
library(ggplot2)
library(dplyr)
library(scales)  
library(tidyr)
install.packages("gganimate")
#install.packages("gganimate")
install.packages("globe4r")
install.packages("remotes")
library(gganimate)

```

```{r}
#| label: load-dataset
#| message: false
#| warning: false
#| echo: false
#| 
pip_row_data <- read.csv('data/pip_dataset.csv')
ex_pro_data <- read.csv('data/globalextremepovertyrate_world-bank2020.csv')
```

## Justification of approach
Stacked bar charts are effective for showing the total amount as well as the composition of that total. By presenting data on people living in and out of extreme poverty as parts of a whole for each year, this visualization clearly demonstrates how total populations and their poverty statuses have evolved over nearly two centuries

This visualization strategy leverages the strengths of stacked bar charts for handling compositional data over time, making it an ideal choice for presenting complex historical data(broad range of years (from 1820 to 2017)) on poverty in a format that is both informative and visually compelling.

## Questions 01: Who is Conquering Extreme Poverty in Various Global Regions Across Time? How does the distribution of wealth differ among various income groups?

### Plot 01 : Stacked Bar Chart to know Poverty Trends over the year in the World

#### **Dependency Columns:**

For Plot 01 dependent columns are `"Number.of.people.living.in.extreme.poverty"`, `"Number.of.people.not.living.in.extreme.poverty"` & `"year"`

```{r}
#| label: stacked-bar-chart
#| message: false
#| warning: false
#| echo: false

# Filter the data to include only specified years
years_to_include <- c(1820, 
                      1850, 
                      1870, 
                      1890, 
                      1910, 
                      1929, 
                      1950, 
                      1960, 
                      1970, 
                      1980:2017)
ex_pro_data_filtered <- ex_pro_data %>%
  filter(Year %in% years_to_include) %>%
  mutate(Year = factor(Year, 
                       levels = years_to_include))  

# Transform data for plotting in a long format suitable for ggplot2
ex_pro_data_long <- pivot_longer(
  ex_pro_data_filtered,
  cols = c( "Number.of.people.living.in.extreme.poverty", 
            "Number.of.people.not.living.in.extreme.poverty"),
  names_to = "Status",
  values_to = "Count"
) %>%
    mutate(Count = Count / 1e9,  
         Status = recode(Status,
                         "Number.of.people.living.in.extreme.poverty" = "Population Live In Extreme Poverty",
                         "Number.of.people.not.living.in.extreme.poverty" = "Population Live Not in Extreme Poverty"))

# Stacked Bar Chart with counts on bars
stacked_absolute_bar_chart <- ggplot(ex_pro_data_long, 
                                     aes(x = Year, 
                                         y = Count, 
                                         fill = Status)) +
  geom_bar(stat = "identity") +
  geom_text(
    aes(label = scales::comma(Count, 
                              accuracy = 0.1), 
        group = Status),
    position = position_stack(vjust = 0.5),  
    color = "black",  
    size = 4  
  ) +
  labs(title = "Polulation Living in Extreme Poverty Level Around the World",
       subtitle = "Year: (1820-2017)",
        caption ="Data source: Ravallion (2016) updated with World Bank (2019) \nLink: OurWorldInData.org/poverty",
       x = "Year", 
       y = "Number of Population (Billions)",
       fill = "Status") +
  theme_minimal() +
  theme(legend.position = "bottom",
         plot.title = element_text(size = 20, 
                              face = "bold", 
                              hjust = 0.5),
         plot.subtitle = element_text(size = 18, 
                                 face = "bold", 
                                 hjust = 0.5),
         plot.caption = element_text(size = 10, 
                                 hjust = 1))  

# save the plots
ggsave("images/stacked_absolute_bar_chart.png", 
       stacked_absolute_bar_chart, 
       width = 17, 
       height = 8, 
       bg="white")

# Animated Plot
animated_plot <- stacked_absolute_bar_chart +
  transition_layers(
    layer_length = 1,    
    transition_length = 2,  
    keep_layers = TRUE  
  ) +
  enter_fade() +         
  enter_drift(x_mod = 1, y_mod = -1) +  
  exit_fade() +          
  ease_aes('linear')    

# Render the animation
#anim_save("images/animated_stacked_bar_chart02.gif", 
#          animated_plot, 
#          width = 1100, 
#          height = 600, 
#         fps = 10, 
#          duration = 15)
```

<img src="images/animated_stacked_bar_chart02.gif" alt="Stacked Bar Chart of Population by Poverty Status" width="100%"/>

**Visualization Descriptions:**

The global population's historical data, from 1820 to 2017, is visualized as a bar chart that shows those living in and out of extreme poverty. It displays two segments: those living in extreme poverty are indicated in the top segment `(shown in red)`, while the people not living in extreme poverty is represented in the bottom segment `(shown in blue`). The blue segment shows a clear increase over time, indicating a decrease in extreme poverty rates and an increase in the population living above the poverty line. On the other hand, there is a good tendency toward the reduction of poverty as the red segment diminishes, which is particularly evident after 1980. The population counts in billions are provided by the text labels on each bar segment. The referenced data source, Ravallion (2016), has been updated with additional information including World Bank (2019) data.

### Plot 02 : Distribution of Wealth Inequality Across Different Income Groups

#### **Dependency Columns:**

For Plot 02 dependent columns are `"gini"`, `"palma_ratio"`, `"s80_s20_ratio"`, `"p90_p10_ratio"`, `"p90_p50_ratio"`, `"p50_p10_ratio"` and `"mld"`

```{r}
#| label: 3D Illustration
#| message: false
#| warning: false
#| echo: false

library(ggplot2)
library(ggridges) 
library(dplyr)
library(viridis)  

# Transforming the data into a long format suitable for ridge plots
pip_data_long <- pip_row_data %>%
  pivot_longer(
    cols = c("gini", 
             "palma_ratio", 
             "s80_s20_ratio", 
             "p90_p10_ratio", 
             "p90_p50_ratio", 
             "p50_p10_ratio", 
             "mld"),
    names_to = "Inequality_Metric",
    values_to = "Metric_Value"
  ) %>%
  mutate(Inequality_Metric = recode(Inequality_Metric,
                                    "gini" = "National Income Inequality",
                                    "palma_ratio" = "Wealth Disparity Ratio",
                                    "s80_s20_ratio" = "Richest-poorest Income Ratio",
                                    "p90_p10_ratio" = "Richest-Poorest Gap Ratio",
                                    "p90_p50_ratio" = "Top-Middle Gap Ratio",
                                    "p50_p10_ratio" = "Middle-Poorest Gap Ratio",
                                    "mld" = "Inequality Level Measure"))


# Plotting the ridge plot with a gradient effect using geom_density_ridges_gradient
ridge_plot <- ggplot(pip_data_long, 
                     aes(x = Metric_Value, 
                         y = Inequality_Metric, 
                         fill = ..x..)) +
  geom_density_ridges_gradient(
    scale = 10,
    rel_min_height = 0.01,
    gradient_lwd = 1.
  ) +
  scale_fill_viridis_c(
    name = "Intencity", 
    option = "C"
  ) +
  labs(
    title = "Distribution of Wealth Inequality Across Different Income Groups",
    subtitle = "3D Illustration : Seven Different Metrics", 
    x = "Metric Value of Distribution",
    y = "Inequality Metric of Wealth Disparity",
    fill = "Intencity"
  ) +
  theme_ridges(font_size = 12, 
               grid = TRUE) +
  theme(
    plot.title = element_text(size = 16, 
                              face = "bold", 
                              hjust = 0.5),
    plot.subtitle  = element_text(size = 16, 
                                  hjust = 0.5),
    axis.title.x = element_text(size = 12, 
                                face = "bold", 
                                hjust = 0.5), 
    axis.title.y = element_text(size = 12, 
                                face = "bold", 
                                hjust = 0.5),
    legend.position = "right"
  ) +
  scale_x_continuous(
    limits = c(-2, 
               10),  
    breaks = seq(0, 
                 10, 
                 1)
  )

# Save the plot
ggsave("images/3D_ridge_plot.png", 
       ridge_plot, 
       width = 12, 
       height = 7, 
       bg = "white")

```

<img src="images/3D_ridge_plot.png" alt="Distribution of Wealth Inequality Across Different Income Groups" width="100%"/>

#### Visualization Descriptions:

Less inequality is often suggested by higher values in the context of metrics such as the `Gini coefficient`, `Palma ratio`, or `S80/S20 ratio`, whereas more inequality is often suggested by lower values.

**Darker hues:** approaching the color purple, would symbolize a more equitable distribution, where income is dispersed more equally among the populace.

**Brighter hues:** which resemble yellow more closely, would be indicative of greater inequality and wealth concentration in a smaller number of hands. As an illustration, a country's level of inequality would be shown by a `Gini coefficient` that is closer to 0 (darker colors) or closer to 1 (brighter colors). In the same way, lower values for the `Palma` and `S80/S20 ratios` would indicate a narrower gap between the wealthiest and poorest groups in society.

## Discussion

## References

\[1\] Source Data link : [*https://ourworldindata.org/grapher/world-population-in-extreme-poverty-absolute?time=earliest..2015*](https://ourworldindata.org/grapher/world-population-in-extreme-poverty-absolute?time=earliest..2015)

\[2\] Used Generative AI to know the solutions of the errors link: <https://chat.openai.com/>

\[3\] Used some techniques an codes from class lectures ppt file, Link: <https://datavizaz.org/>\

## Question 2


```{r}
# running the UI
#shinyApp(ui = ui, server = server)
library(ggplot2)
library(sf)
library(dplyr)
library(rnaturalearth)
library(rnaturalearthdata)
library(magick)
library(globe4r)

# Read the CSV file into a data frame
my_data <- read.csv("data/pip_dataset.csv")
country_lat_long <- read.csv("data/country_pin.csv")

pip_final <- read.csv("data/cleaned_pip_final.csv")

```


```{r}
# Read the dataset
pip_final <- read.csv("data/cleaned_pip_final.csv")

# Filter the dataset to include only rows where year is 1996 and ppp_version is 2017
filtered_data <- pip_final %>%
  filter(year == 1996, ppp_version == 2017)

# Select one unique row per country
# Assuming you want to keep the first occurrence
unique_countries_data <- filtered_data %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Merge your data with the world map
world_data <- world %>%
  left_join(unique_countries_data, by = c("name" = "Country"))

# Scale the "gini" column from 1 to 10 integer values
world_data$gini_scaled <- cut(world_data$gini, breaks = 10, labels = FALSE)

# Plotting the heatmap with labels
ggplot(data = world_data) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  geom_sf_text(aes(label = as.character(gini_scaled)), size = 5, color = "black", check_overlap = TRUE) +  # Add labels from the "gini" column
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio", na.value = "grey90") +  # Use viridis color palette
  labs(title = "Headcount Ratio at International Poverty Line", fill = "Headcount Ratio", color = "Gini Index") +
  theme_minimal() +
  theme(legend.position = "right",  # Move legend to the right
        legend.title = element_text(size = 12, face = "bold"),  # Adjust legend title appearance
        legend.text = element_text(size = 10),  # Adjust legend text appearance
        plot.title = element_text(size = 16, face = "bold"),  # Adjust plot title appearance
        panel.background = element_rect(fill = "lightblue"))  # Set background color

```


```{r}
# Read the dataset
pip_final <- read.csv("data/cleaned_pip_final.csv")

# Filter the dataset to include only rows where ppp_version is 2017
filtered_data <- pip_final %>%
  filter(ppp_version == 2017)

# Year 2010
unique_countries_data_2010 <- filtered_data %>%
  filter(year == 2010) %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

world <- ne_countries(scale = "medium", returnclass = "sf")

world_data_2010 <- world %>%
  left_join(unique_countries_data_2010, by = c("name" = "Country"))

plot_2010 <- ggplot(data = world_data_2010) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio") +
  labs(title = "Headcount Ratio at International Poverty Line (2010)") +
  theme_minimal() +
  theme(legend.position = "bottom")

#ggsave("poverty_map_2010.jpg", plot_2010, width = 8, height = 6, dpi = 300)

# Year 2012
unique_countries_data_2012 <- filtered_data %>%
  filter(year == 2012) %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

world_data_2012 <- world %>%
  left_join(unique_countries_data_2012, by = c("name" = "Country"))

plot_2012 <- ggplot(data = world_data_2012) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio") +
  labs(title = "Headcount Ratio at International Poverty Line (2012)") +
  theme_minimal() +
  theme(legend.position = "bottom")

#ggsave("poverty_map_2012.jpg", plot_2012, width = 8, height = 6, dpi = 300)

# Year 2015
unique_countries_data_2015 <- filtered_data %>%
  filter(year == 2015) %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

world_data_2015 <- world %>%
  left_join(unique_countries_data_2015, by = c("name" = "Country"))

plot_2015 <- ggplot(data = world_data_2015) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio") +
  labs(title = "Headcount Ratio at International Poverty Line (2015)") +
  theme_minimal() +
  theme(legend.position = "bottom")

#ggsave("poverty_map_2015.jpg", plot_2015, width = 8, height = 6, dpi = 300)

# Year 2016
unique_countries_data_2016 <- filtered_data %>%
  filter(year == 2016) %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

world_data_2016 <- world %>%
  left_join(unique_countries_data_2016, by = c("name" = "Country"))

plot_2016 <- ggplot(data = world_data_2016) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio") +
  labs(title = "Headcount Ratio at International Poverty Line (2016)") +
  theme_minimal() +
  theme(legend.position = "bottom")

#ggsave("poverty_map_2016.jpg", plot_2016, width = 8, height = 6, dpi = 300)

# Year 2018
unique_countries_data_2018 <- filtered_data %>%
  filter(year == 2018) %>%
  group_by(Country) %>%
  slice(1) %>%
  ungroup()

world_data_2018 <- world %>%
  left_join(unique_countries_data_2018, by = c("name" = "Country"))

plot_2018 <- ggplot(data = world_data_2018) +
  geom_sf(aes(fill = headcount_ratio_international_povline), color = "white") +
  scale_fill_viridis_c(option = "C", direction = -1, name = "Headcount Ratio") +
  labs(title = "Headcount Ratio at International Poverty Line (2018)") +
  theme_minimal() +
  theme(legend.position = "bottom")

#ggsave("poverty_map_2018.jpg", plot_2018, width = 8, height = 6, dpi = 300)
```


```{r}
# Display the gif
image_read("Merged_document.gif") %>%
  image_scale("500") %>%  # Resize the image to 500 pixels wide
  image_animate(fps = 5)  # Speed up the animation to 10 frames per second
```

```{r}
# Read the dataset
pip_final <- read.csv("data/cleaned_pip_final.csv")

# Count the occurrences of each unique year
year_counts <- table(pip_final$year)

# Sort the counts in descending order and select the top 10
top_10_years <- sort(year_counts, decreasing = TRUE)[1:10]

# Display the top 10 most occurring years
print(top_10_years)

```

```{r}
# Read the dataset
pip_final <- read.csv("data/cleaned_pip_final.csv")

head(pip_final)

# Filter the dataset to include only rows where ppp_version is 2017
pip_final_2018 <- pip_final %>%
  filter(ppp_version == 2017, year == 2018) %>%
  select(Country.Code, Country, year, Latitude, Longitude, gini,headcount_ratio_international_povline)

# Remove duplicate country rows
pip_final_unique <- pip_final_2018 %>%
  distinct(Country, .keep_all = TRUE)

# Scale the "headcount_ratio_international_povline" and "gini" columns
pip_final_scaled <- pip_final_unique %>%
  mutate(headcount_ratio_international_povline_scaled = 
           (headcount_ratio_international_povline - min(headcount_ratio_international_povline)) /
           (max(headcount_ratio_international_povline) - min(headcount_ratio_international_povline)),
         gini_scaled = 
           (gini - min(gini)) /
           (max(gini) - min(gini)))

pip_final_scaled <- pip_final_scaled %>%
  mutate(
    Latitude = round(as.numeric(Latitude), 2),
    Longitude = round(as.numeric(Longitude), 2)
  )

# Add text labels to the globe
globe <- create_globe(height = "100vh") %>%
  labels_data(data = pip_final_scaled) %>%  # Provide your dataset here
  labels_lat(lat = "Latitude") %>%  # Specify the column containing latitude information
  labels_lon(lon = "Longitude") %>%  # Specify the column containing longitude information
  labels_text(text = "Country") %>%  # Specify the column containing text information
  labels_altitude(altitude = 30)  # Specify the altitude for the text labels


# Create the globe choropleth plot
globe <- globe %>%
  globe_choropleth(
    coords(
      country = Country.Code,  # Using ISO2 country codes
      altitude = headcount_ratio_international_povline_scaled,
      cap_color = headcount_ratio_international_povline_scaled  # Color caps based on scaled poverty headcount
    ), 
    data = pip_final_scaled
  ) %>%
  polygons_side_color(color = constant("#ffffaa60")) %>%
  scale_choropleth_cap_color() %>%  # Adjust color scaling if needed
  scale_choropleth_altitude(0.04, 0.2) %>% 
  globe_img_url(image_url("blue")) # Adjust the altitude scale to match the range of your data

# Rotate the globe automatically
globe <- globe_rotate(globe, speed = 0.5L, rotate = TRUE)

# Print the globe
print(globe)

```

